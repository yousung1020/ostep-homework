## 1. 가상화의 핵심 원리: 제한적 직접 실행 (Limited Direct Execution)

- 효율적인 CPU 가상화를 위해 프로그램을 물리적 CPU에서 직접 실행하는 기법
    
- 성능 저하 최소화와 시스템 제어권 유지가 핵심 도전 과제
    
- 하드웨어적 지원을 통한 사용자 모드와 커널 모드의 분리 운영
    
- 시스템 콜을 통한 보호된 제어 양도 및 특권 연산 수행
    

## 2. 제어권 확보 및 모드 전환 메커니즘

- 트랩 테이블(Trap Table): 부팅 시 커널이 하드웨어에 등록하는 예외 핸들러 주소 목록
    
- 타이머 인터럽트: 비협조적 프로세스로부터 강제로 CPU를 회수하는 핵심 수단
    
- 리턴 프롬 트랩(Return-from-trap): 커널 스택에서 레지스터를 복원하며 사용자 모드로 복구하는 명령어
    

## 3. 문맥 교환(Context Switch)의 정교한 설계

- 현재 실행 중인 프로세스의 레지스터 상태 보관 및 다음 프로세스의 상태 복원 과정
    
- 2단계 저장 구조: 인터럽트 시 하드웨어의 자동 저장(사용자 레지스터) 및 switch() 호출 시 소프트웨어의 수동 저장(커널 레지스터)
    

### 3-1. xv6 switch 어셈블리 코드 분석

- movl 4(%esp), %eax: 스택에서 첫 번째 인자인 이중 포인터(old) 주소 획득
    
- popl 0(%eax): 스택 최상단 리턴 주소(IP)를 추출하여 보관함의 0번 지점에 저장
    
- movl %esp, 4(%eax): 현재 프로세스의 스택 포인터 위치를 보관함에 기록
    
- movl 4(%eax), %esp: CPU의 스택 포인터(%esp)를 새 프로세스의 커널 스택으로 강제 전환
    
- pushl 0(%eax): 보관함에 있던 새 프로세스의 리턴 주소를 새 스택 꼭대기에 배치
    
- ret: 새 프로세스가 이전에 멈췄던 지점으로 실행 주체 이동
    

## 4. 성능 측정 및 기술적 통찰

- 시스템 콜 비용 측정: 0바이트 read() 호출 루프를 통한 평균 처리 시간 산출
    
- 문맥 교환 비용 측정: 두 프로세스 간 UNIX 파이프 왕복 통신 및 봉쇄(Block) 유도
    
- 정밀도 확보: gettimeofday()의 한계를 고려하여 x86 rdtsc 명령어 사용 검토
    
- 하드웨어적 한계: CPU 성능 향상 대비 메모리 대역폭의 느린 발전으로 인한 운영체제 연산의 병목 현상 확인
    

## 5. 학습 결론

- 이중 포인터(**old) 참조를 통한 프로세스 구조체(proc) 내부의 실행 문맥 실시간 갱신 원리 파악
    
- 스택의 하향 성장 특성을 이용한 상대 주소(Offset) 접근 및 제어 흐름 이해
    
- 하드웨어와 OS 간의 정교한 프로토콜이 멀티태스킹 가상화의 근간임을 확인