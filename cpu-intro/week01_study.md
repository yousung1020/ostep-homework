## 1. 운영체제(OS) 핵심 개념 정리

### 1.1 프로세스(Process)의 개념과 주요 기능(API)
- **정의**: 프로그램은 저장 장치에 있는 정적인 레시피라면, 프로세스는 메모리에 로드되어 CPU가 실행 중인 살아있는 상태를 의미함.
- **프로세스 API**: 현대 운영체제는 프로세스 관리를 위해 5가지 핵심 기능을 제공함.
    - **생성(Create)**: 새로운 프로세스를 생성함.
    - **제거(Destroy)**: 프로세스를 강제로 중단함.
    - **대기(Wait)**: 실행 중인 프로세스가 멈추기를 기다림.
    - **제어(Miscellaneous Control)**: 일시 정지나 재개 등 다양한 제어 기능을 수행함.
    - **상태(Status)**: 실행 시간이나 현재 상태 등 프로세스의 정보를 확인함.

### 1.2 프로세스 생성 과정 (Loading)
- 프로그램이 프로세스로 변하기 위해 운영체제는 다음과 같은 정교한 단계를 거침.
    1. **탑재(Load)**: 디스크의 코드와 정적 데이터를 메모리의 주소 공간으로 읽어 들임.
    2. **스택(Stack) 할당**: 지역 변수와 함수 인자를 위한 메모리를 할당하고 argc, argv 등으로 초기화함.
    3. **힙(Heap) 할당**: 동적 메모리 할당을 위한 영역을 준비함.
    4. **입출력(I/O) 초기화**: 표준 입력, 출력, 에러 등 기본 파일 디스크립터를 설정함.
    5. **시작**: 진입점인 `main()` 함수를 호출하여 실제 실행을 시작함.

### 1.3 하드웨어 상태와 메모리 구조
- **하드웨어 상태(Machine State)**: 실행 상태를 결정하는 핵심은 메모리와 레지스터임.
    - **프로그램 카운터(PC)**: 다음 명령어 주소를 가리키는 책갈피임.
    - **스택 포인터(SP)**: 현재 스택의 꼭대기를 가리키며 경계를 관리함.
- **스택의 동작**: 높은 주소에서 낮은 주소로 자라며, 공간 확보를 위해 SP 값을 빼는(-) 연산을 수행함. 경계를 넘으면 **스택 오버플로우** 에러가 발생함.

### 1.4 프로세스의 상태와 전이 (State Transition)
- 프로세스는 크게 세 가지 상태를 오가며 실행됨.
    - **실행(Running)**: CPU에서 명령어를 실행 중인 상태.
    - **준비(Ready)**: 실행 가능하지만 OS의 선택을 기다리는 상태.
    - **대기(Blocked)**: I/O 완료 등을 기다리며 CPU를 사용하지 않는 상태.
- **상태 전이**: 스케줄링에 의해 '실행 <-> 준비'가 일어나고, I/O 요청 시 '실행 -> 대기', 완료 시 '대기 → 준비'로 이동함.
- **좀비(Zombie) 상태**: 프로세스는 끝났으나 부모가 종료 확인을 안 해 정보가 남아있는 특수한 상태임.

### 1.5 운영체제의 내부 자료 구조
- **PCB(Process Control Block)**: 각 프로세스의 레지스터 context, 상태, PID, 부모 프로세스, 열린 파일 목록 등을 담는 핵심 구조체임.
- **프로세스 리스트**: 시스템 전체 프로세스를 관리하는 목록임.
- **문맥 교환(Context Switch)**: 실행 중단 시 현재 레지스터 값을 PCB에 저장하고, 재개 시 복원하는 작업임.

---

## 2. `process-run.py` 실습 분석

### 2.1 입출력(I/O) 메커니즘의 이해
- **I/O의 독립성**: 입출력은 CPU가 직접 하지 않고 외부 하드웨어가 담당함.
- **1+5+1 법칙**: 시뮬레이터에서 I/O는 '시작(1) + 대기(5) + 종료 처리(1)'로 총 7틱을 소모하며, 대기 중에는 **BLOCKED** 상태가 됨.

### 2.2 스케줄링 효율성 실험 결과
- **실험 1 (CPU 전용)**: CPU 연산만 있으면 `BLOCKED` 없이 이용률 100%를 달성함.
- **실험 2 (순서와 자원 겹치기)**: I/O를 먼저 시작하면 그 대기 시간 동안 다른 프로세스가 CPU를 쓸 수 있어(Overlap), 전체 시간이 11틱에서 7틱으로 단축됨.
- **실험 3 (정책 분석)**: 
    - `SWITCH_ON_IO`: I/O 즉시 전환하여 효율 극대화.
    - `IO_RUN_IMMEDIATE`: I/O 완료 프로세스를 즉시 깨워 자원 활용도를 높임.

---

## 3. 학습 회고 및 백엔드 개발자와의 연결

### 3.1 자원 겹치기(Overlap)의 가치
운영체제의 실력은 CPU와 I/O 장치를 얼마나 동시에 바쁘게 돌리느냐(Overlap)에 달려 있음을 배움. 이는 시스템 전체 처리량(Throughput)을 결정하는 결정적인 요소임.

### 3.2 자료 구조와 엔지니어링 마인드
PCB와 문맥 교환 개념을 통해, 추상적인 '실행'이라는 개념이 실제로는 메모리 속의 구조체와 레지스터 값의 복사 과정이라는 실체를 알게 됨. 이는 나중에 고성능 서버를 설계할 때 컨텍스트 스위칭 비용을 왜 고려해야 하는지 깨닫게 해준 중요한 지점임.

### 3.3 미래의 나를 위한 통찰
스프링 부트 서버에서 수많은 요청을 처리할 때, 각 요청이 어떤 상태(Running, Blocked 등)에 머무는지 이해하는 것이 성능 최적화의 시작임을 알게 됨. 특히 DB 조회 시 발생하는 Blocked 시간을 어떻게 효율적으로 관리할지 OS 관점에서 고민하는 능력을 기르게 됨.
