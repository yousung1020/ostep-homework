1. 길이가 200인 세 개의 작업을 SJF와 FIFO 스케쥴링 방식으로 실행할 경우 응답 시간과 반환 시간을 계산하시오.
	- 스케쥴링 순서: 모든 작업의 길이가 같으므로, FIFO와 SJF의 처리 순서 및 결과가 동일함
	- 응답 시간: SJF, FIFO 모두 0, 200, 400 이므로, 평균 응답 시간은 **200**이다.
	- 반환 시간: SJF, FIFO 모두 200, 400, 600 이므로, 평균 반환 시간은 **400**이다.
	- 결과 확인 명령어:
		- python3 ./scheduler.py -p SJF -j 3 -l 200,200,200 -c
		- python3 ./scheduler.py -p FIFO -j 3 -l 200,200,200 -c
2. 같은 조건이지만 작업의 길이가 각각 100, 200 및 300일 경우에 대해 계산하시오.
	- 스케쥴링 순서: 오름차순으로 도착했으므로 FIFO와 SJF의 처리 순서가 동일함
	- 응답 시간: SJF, FIFO 모두 0, 100, 300 이므로, 평균 응답 시간은 **133.33...** 이다.
	- 반환 시간: SJF, FIFO 모두 100, 300, 600 이므로, 평균 반환 시간은 **333.33...** 이다.
	- 결과 확인 명령어:
		- python3 ./scheduler.py -p SJF -j 3 -l 100,200,300 -c
		- python3 ./scheduler.py -p FIFO -j 3 -l 100,200,300 -c
3. 2번과 같은 조건으로 타임 슬라이스가 1인 RR 스케쥴러에 대해서도 계산하시오.
	- 응답 시간: 0, 1, 2 이므로, 평균 응답 시간은 **2**이다.
	- 반환 시간: 세 개의 작업이 1씩 교차 실행되는 구조이므로 작업0, 1, 2에 대해서 다음과 같은 반환 시간을 갖게된다.
		1. 작업0 종료 시점: 세 작업이 **100**씩 나눈 시점인 **298** (99 * 3 + 1)
		2. 작업1 종료 시점: 남은 **100**을 두 작업이 나눈 시점인 **499** (100 * 2 + 299)
		3. 작업2 종료 시점: 마지막 **100**을 단독 실행한 시점인 **600** (100 * 1 + 500)
		- 그러므로 평균 반환 시간은 **465.67**이다.
	- 결과 확인 명령어:
		- python scheduler.py -p RR -l 100,200,300 -q 1 -c
4. SJF와 FIFO가 같은 반환 시간을 보이는 워크로드의 유형은 무엇인가?
	- 조건: 모든 작업이 실행 길이의 오름차순(가장 짧은 작업부터)으로 도착하는 형태
	- 이유: FIFO의 선입선출 흐름이 SJF의 최단 작업 우선 원리와 완전히 일치하기 때문
5. SJF가 RR과 같은 응답 시간을 보이기 위한 워크로드와 타임 퀀텀의 길이는 무엇인가?
	* 조건: 모든 작업의 실행 시간이 동일하고, RR의 타임 퀀텀(타임 슬라이스)이 그 실행 시간보다 크거나 같은 경우
	* 이유: 타임 퀀텀이 더 길면 문맥 교환이 일어나기 전에 작업이 끝나버리므로, 사실상 RR이 비선점형 FIFO/SJF처럼 동작함
6. 작업의 길이가 증가하면 SJF의 응답 시간은 어떻게 되는가? 변화의 추이를 보이기 위해서 시뮬레이터를 사용할 수 있는가?
	- 변화 추이: 앞선 작업들의 실행 시간이 주어짐에 따라 대기 줄에 있는 뒤쪽 작업들의 평균 응답 시간이 선형적으로 증가함
	- 관찰 사용 가능 여부: '-m' (최대 길이) 옵션 수치를 점진적으로 키워 수치 상승 관찰 가능
7. 타임 퀀텀의 길이가 증가하면 RR의 응답 시간은 어떻게 되는가? N개의 작업이 주어졌을 때, 최악의 응답 시간을 계산하는 식을 만들 수 있는가?
	- 변화 추이: 퀀텀이 길어질수록 순환 주기가 느려져 각 작업이 최초로 CPU를 점유하기까지의 응답 시간이 증가함
	- 최악의 응답 시간 산출 식: (N - 1) * 타임퀀텀
	- 수식의 의미: N개의 작업이 동시 도착 시, 마지막 N번째 작업은 앞선 N - 1개의 작업이 각각 한 번씩 타임 퀀텀을 소모할 때까지 전부 기달려야 함